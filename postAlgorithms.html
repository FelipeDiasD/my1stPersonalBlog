<!DOCTYPE html>
<html lang="pt-br">

<head>

    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DiasBlog</title>

    <link rel="icon" type="image/x-icon" href="./assets/images/post-svgrepo-favicon.svg" />

    <link rel="stylesheet" href="style.css" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;700;900&display=swap" rel="stylesheet">

</head>

<body>

    <header class="first-header">

        <h1>Dias Blog</h1>
        <nav>
            <a href="index.html">Home</a>
            <a href="aboutTheAuthor.html">Sobre o autor</a>
            <a href="contactMe.html">Contatos</a>
        </nav>

        <button onclick="openMenu()" class="open-menu">
            <?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
            <svg width="50px" height="50px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd"
                    d="M5 7C5 6.44772 5.44772 6 6 6H18C18.5523 6 19 6.44772 19 7C19 7.55228 18.5523 8 18 8H6C5.44772 8 5 7.55228 5 7ZM5 12C5 11.4477 5.44772 11 6 11H18C18.5523 11 19 11.4477 19 12C19 12.5523 18.5523 13 18 13H6C5.44772 13 5 12.5523 5 12ZM5 17C5 16.4477 5.44772 16 6 16H18C18.5523 16 19 16.4477 19 17C19 17.5523 18.5523 18 18 18H6C5.44772 18 5 17.5523 5 17Z"
                    fill="#E8E8EA" />
            </svg>
        </button>
    </header>



    <div class="menu">
        <ul>
            <li><a onclick="closeMenu()" href="#main">Home</a></li>
            <li><a onclick="closeMenu()" href="#">Sobre o autor</a></li>
            <li><a href="#">Contatos</a></li>
        </ul>
    </div>


    <header class="post-header">
        <h1>Algoritmos</h1>
        <p>
            Nesse post abordarei sobre o tema algoritmos, sua definição, seus componentes e assuntos complementares.
        </p>
    </header>

    <article class="content">
        <h2>O que são algoritmos?</h2>

        <p>
            Quando pensamos em algoritmos, essa palavra grande pode gerar uma série de pensamentos diferentes na
            primeira vez que ouvimos.
            Apesar disso, o significado dela é relativamente simples. Algoritmo é uma sequência de passos que se dá, ou
            que se planeja para que
            uma tarefa seja executada tendo como finalidade um resultado. Para ilustrar esse conceito o exemplo mais
            utilizado é uma receita de um prato, como um bolo. Essa receita dirá o que você precisa ter e o que
            precisa fazer para que no fim você tenha o resultado desejado, no caso o bolo.

        </p>

        <p>
            No caso da nossa receita de bolo, citamos que ela nos informa os ingredientes que precisamos, os passos que
            precisamos seguir para
            fazer o bolo e também nos diz o que esperar como resultado. Respectivamente um algoritmo também terá 3
            principais pontos, que são:


        <ul>
            <li>As Entradas: É todo dado necessário que o algoritmo irá receber para realizar o seu passo a passo afim
                de atingir o resultado esperado. </li>

            <li> O processamento: É a parte central do algoritmo e podemos dizer que é sua essência, na qual os passos
                definidos vão processar os dados recebidos na entrada.</li>

            <li> A saída: Aqui temos os dados que foram processados pelo algoritmo, é onde verificamos se o resultado
                era o esperado ou não.</li>
        </ul>

        Sendo assim, os ingredientes de um receita são suas entradas, o modo de preparo seria o processamento e por fim
        o resultado
        é sua saída. Acredito que essa seja a melhor maneira de visualizar o que realmente é um algoritmo.

        </p>

        <p>
            Se pensarmos bem, os algoritmos estão em toda parte. Tudo que fazemos pode ser separado em entradas,
            processamento e saídas.
            No
            contexto de desenvolvimento de software, nós aplicamos este conceito para dar instruções ao computador, afim
            de se obter resultados específicos.
            Fazemos isso através das linguagens de programação, como Java, C, Javascript, entre outras. A principal
            diferença entre um
            algoritmo qualquer e um criado para o computador está no fato de que o computador é uma máquina literal e
            precisa que
            descrevamos com exatidão o que queremos. No caso, podemos citar um exemplo como um algoritmo para quebrar um
            ovo.

        <h4>Quebre um ovo</h4>
        <ul>
            <li> Pegue o ovo</li>

            <li> Quebre a casca</li>

            <li> Abra cuidadosamente o mesmo em cima de um recipiente</li>

        </ul>

        Se hipoteticamente disséssemos a um computador para fazer isso, talvez surgiriam as seguintes questões.
        <ul>
            <li> Com o que vou pegar o ovo? </li>

            <li> Como vou quebrar? Com o que irei quebrar?</li>

            <li> Como devo abrir? Que recipiente? Onde está o recepiente?</li>
        </ul>

        Deste modo, temos que especificar muito bem o que queremos em cada passo para que o computador possa nos dar o
        resultado que esperamos.<br /><br />

        Por fim, podemos representar os algoritmos, através da escrita de um pseudocódigo, descrevendo os mesmos numa
        linguagem próxima da humana, como o Portugol e também através de
        fluxogramas ou diagramas de blocos.

        <figure>
            <div class="image-wrapper">
                <img src="./assets/images/Imagem00_postAlgoritmos.png">



            </div>
            <figcaption>Representação de um algoritmo</figcaption>
        </figure>



        <h2>Refinando: Estruturas dos algoritmos</h2>

        Agora que já definimos o que é um algoritmo, vamos aprender sobre algumas estruturas internas que nos auxiliam a
        construir algoritmos
        e são comuns na maioria das linguagens de programação.

        <h3>Variáveis</h3>

        <p>
            Quando pensamos em variáveis, pensamos em alguma coisa que varia, se altera, muda, certo? No contexto de
            algoritmos,
            variável será onde guardaremos um dado, que pode se alterar ao longo do processamento ou não. Esse dado pode
            ser
            um dado de
            entrada ou mesmo de saída, como uma variável para guardar o resultado de uma soma, por exemplo. Numa soma,
            temos
            dois números de entrada,
            o processamento e o resultado, de modo que, tanto as entradas e saídas podem ser armazenadas em variáveis:

        <ul>
            <li> variável número1 -> recebe -> 1 </li>

            <li> variável número2 -> recebe -> 1</li>

            <li> soma -> variável número1 + variável número2</li>

            <li> variável resultado -> recebe -> resultado de soma (2)</li>

        </ul>

        Este exemplo ilustra como podemos armazenar as entradas e saídas de um algoritmo, fazendo com que possamos ter a
        possibilidade de reutilizar
        tais variáveis. De modo que, não somente podemos armazenar números, mas também outros tipos de dado. Podemos
        resumir os tipos de dado mais comuns
        a 3 tipos: <br />
        <ul>
            <li>Dados numéricos (reais, fracionados...) </li>

            <li>Dados textuais (caracteres, palavras...)</li>

            <li>Dados booleanos (falso ou verdadeiro)</li>

        </ul>

        Por fim, no contexto computacional, cada variável será armazenada em um local na memória do computador, com cada
        linguagem de programação tendo uma estratégia de alocação de memória para as variáveis.
        </p>


        <h3>Estruturas condicionais</h3>

        Agora vejamos, nos deparamos uma situação na qual precisamos decidir uma ação que depende de uma condição, e
        agora?
        Para isso tempos as estruturas condicionais. Estas estruturas se baseiam na condição que lhes é atribuída para
        realizar
        uma decisão e continuar o processamento. Se esta condição for verdadeira, então faça isso, caso contrário faça
        aquilo.
        Essa é a lógica utilizada pela estrutura condicional, que comumente é chamada de "se" ou o famoso "if"


        <figure>
            <div class="image-wrapper">
                <img src="./assets/images/Imagem01_postAlgoritmos.png">
            </div>
            <figcaption>Representação de um algoritmo com uma condicional</figcaption>
        </figure>

        Na representação acima, temos a entrada de uma situação que é a lâmpada não funcionando, na
        continuidade do algoritmo, temos 2 condicionais

        <ul>
            <li>A lâmpada está ligada? - Se esta condição for verdadeira eu sigo para a próxima condição - Caso
                contrário eu executo a ação de ligar a lâmpada </li>

            <li>O bulbo está queimado? - Se esta condição for verdadeira eu executo a ação de substituir a lâmpada -
                Caso
                contrário eu sigo para a minha ação final</li>

            <li>Caso nenhuma condição seja verdadeira eu vou consertar essa lâmpada</li>

        </ul>

        Deste modo, a estrutura condicional será utilizada sempre que temos uma tomada de decisão dependente de um fator
        ou uma condição.



        <h3>Estruturas de repetição</h3>

        <p>
            Adicionalmente, temos mais uma estrutura essencial em algoritmos. No caso de precisarmos repetir uma ação
            diversas vezes,
            eu adicionarei vários passos iguais para esse algoritmo? Não é uma opção muito boa, para isso temos as
            estruturas de repetição.
            A lógica inicial da estrutura de repetição é semelhante a condicional, na qual ela verifica uma condição
            pré-estabelecida, para então
            realizar o processamento definido dentro da estrutura. Depois de realizado esse processamento, ela volta a
            verificar a condicional e a
            depender do resultado da condição programada o processo se repetirá ou não, evitando a repetição de passos.

        <figure>
            <div class="image-wrapper">
                <img src="./assets/images/Imagem02_postAlgoritmos.png">
            </div>
            <figcaption>Representação de um algoritmo com estrutura de repetição</figcaption>
        </figure>


        Na representação acima, temos a nossa variável de entrada que é a nossa roupa de cama suja, na
        continuidade do algoritmo, temos a estrutura de repetição, iniciando com uma condicional

        <ul>
            <li>A roupa está suja? - Se esta condição for verdadeira eu adentro minha estrutura de repetição - Caso
                contrário eu sigo para a saída e vou recolher a roupa </li>

            <li> Após a lavagem de 20 minutos eu refaço a pergunta da condicional -Se esta condição for verdadeira
                novamente
                eu continuo em minha estrutura de repetição, e isso se segue até a nossa variável roupa estar limpa</li>

        </ul>

        No mais, utilizamos essa estrutura sempre que quisermos que um passo se repita.

        </p>


        <h2>Tipos de algoritmos e estruturas de dados</h2>

        <p>
            Agora que vimos o que é e quais as principais estruturas de um algoritmo, podemos nos aprofundar brevemente
            em alguns tipos comuns de algoritmos e o que são estruturas de dados.<br />
            Abaixo cito princilpamente dois tipos de algoritmos, muito utilizados na programação.

        <ul>
            <li>Algoritmos de ordenação: Como o nome já diz, tais algoritmos tem a função de ordenar ou organizar um
                conjunto de dados,
                como uma lista de números por exemplo.<br />
                Exemplos: Bubble sort, quick sort, merge sort.
            </li>
            <li>Algoritmos de busca: São algoritmos que tentam localizar um dado exato em meio a um conjunto de
                dados.<br />
                Exemplos: Binary Search, Linear Search </li>
        </ul>

        Existem outros tipos, como algoritmos gulosos, de recursão e por aí vai, porém de início, acredito que estes
        sejam
        aqueles pra se manter em vista.<br />

        Complementando os algoritmos temos as estruturas de dados. Tais estruturas armazenam dados, assim como as
        variáveis. Porém, diferente de uma
        variável, a estrutura de dado tem uma estratégia para armazenar e manejar seus dados. <br />

        A estrutra mais comum que você encontrará na maioria das linguagens de programação é o vetor ou array. Por
        padrão essa estrutura armazena
        uma série de dados do mesmo tipo, como uma série de números ou caracteres texuais e tem um tamanho fixo. Por fim
        a última característica
        desse tipo de estrutura é a estratégia utilizada para armazenamento. Cada novo elemento adicionado sempre será
        adicionado na última posição
        vazia disponível. <br /><br />

        <div class="behind-the-scenes-content">
            <h3> Um pouco por trás dos panos:</h3>
            <p>

                A alocação de memória de um vetor
                é literalmente feita em sequência na
                memória do computador.

            </p>
        </div>


        <figure>
            <div class="image-wrapper">
                <img src="./assets/images/Imagem03_postAlgoritmos.png">
            </div>
            <figcaption>Representação de um vetor</figcaption>
        </figure>

        É possível definir uma estrutura de dado com as mais diversas estratégias de armazenamento de dados, sendo que
        tais estruturas personalizadas
        são chamadas de tipos abstratos de dados. Nesse contexto de estratégias diferentes, temos as estrutras clássicas
        que podemos citar:


        <ul>
            <li>Pilha<br />
                Também guarda um conjunto de elementos do mesmo tipo e possui tamanho fixo, mas segue a seguinte
                estratégia: <br />
                A inserção de novos elementos é feita no início, ou seja no topo. A retirada de elementos também
                ocorre pelo topo, dando uma característica única que é a de armazenar elementos em uma ordem e os
                retirar pela ordem inversa. Este tipo de estratégia é chamado de FILO (first in, last out) ou UEPS
                (último que entra, primeiro que sai)
                Para visualizar melhor, imagine uma pilha de pratos.

            </li>
            <li>Fila estática <br />
                Guarda um conjunto de elementos do mesmo tipo e possui tamanho fixo, mas segue a seguinte estratégia:
                <br />
                A inserção de novos elementos é feita no final, ou seja na última posição vazia disponível. A retirada
                de elementos
                ocorre pelo início, ou topo. Este tipo de estratégia é chamado de FIFO (first in, first out) ou PEPS
                (primeiro que entra, primeiro que sai)
                Para vizualizar este tipo de estrutura, imagine uma fila qualquer, como a de banco.</li>

            <li>Lista encadeada <br />
                Esta é um pouco diferente das outras, mas de início segue o mesmo princípio de guardar um conjunto de
                elementos do mesmo tipo. Tais elementos serão
                estruturas internas que possuirão uma referência para o próximo elemento, e o último elemento apontará
                para o fim (ou uma posição nula). Aqui posso
                inserir e remover elementos em qualquer posição, justamente por poder alterar pra onde cada estrutura
                apontará.
            </li>

            <figure>
                <div class="image-wrapper">
                    <img src="./assets/images/Imagem04_postAlgoritmos.png">
                </div>
                <figcaption>Representação de uma lista encadeada</figcaption>
            </figure>

        </ul>

        Enfim, as estruturas de dados andam lado a lado com os algoritmos, servindo como ferramentas poderosas na
        criação de um algoritmo efetivo,
        que não só resolve um problema, mas que também o faz mais rapidamente e ocupando o menor espaço. Posso abordar o
        desempenho de algoritmos em
        um próximo post, pois acredito que isto pode ser dissertado a parte. Deste modo, encorajo e indico muito a
        prática de algoritmos, de início
        usando pseudocódigo e posteriormente em sites como
        hackerrank, leetcode e semelhantes. Além de melhorar a nossa capacidade lógica como desenvolvedor, nos
        possibilita escrever códigos
        cada vez melhores. Espero que esse post tenha te auxiliado de alguma maneira, obrigado por chegar até aqui!
        </p>

    </article>